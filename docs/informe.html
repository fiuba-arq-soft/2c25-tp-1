<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
<!-- 2025-10-09 Thu 19:26 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="assets/theme/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="assets/theme/readtheorg_theme/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="assets/theme/readtheorg_theme/css/search.css"/>
<script type="text/javascript" src="assets/theme/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="assets/theme/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="assets/theme/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="assets/theme/readtheorg_theme/js/search.js"></script>
<script type="text/javascript" src="assets/theme/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript">disableSearch();</script>
</head>
<body>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9703863">1. Introducción</a></li>
<li><a href="#org3d9609b">2. Atributos de calidad (QA) claves identificados</a>
<ul>
<li><a href="#orgfde1294">2.1. Disponibilidad</a></li>
<li><a href="#org526a6d0">2.2. Escalabilidad (Elasticidad)</a></li>
<li><a href="#org9b63f96">2.3. Performance</a></li>
<li><a href="#org05491ff">2.4. Visibilidad</a></li>
</ul>
</li>
<li><a href="#orge4f5ffc">3. Arquitectura base</a>
<ul>
<li><a href="#org8932e19">3.1. Análisis de la influencia de decisiones de diseño en los QA's</a></li>
<li><a href="#orge1ba04b">3.2. Incorporación del stack de monitoreo cAdvisor + Artillery + StatsD + Graphite + Grafana</a>
<ul>
<li><a href="#org1dabab8">3.2.1. Impactos identificados</a></li>
</ul>
</li>
<li><a href="#org9060e73">3.3. Impactos del modelo de persistencia elegido</a></li>
<li><a href="#org15f0a9b">3.4. Instancias únicas de cada servicio</a></li>
<li><a href="#org24dc452">3.5. Ausencia de un patrón de arquitectura interna</a></li>
<li><a href="#org41f07ef">3.6. Diagrama C&amp;C inicial.</a></li>
<li><a href="#orgc8913f2">3.7. Crítica a arquitectura base.</a></li>
</ul>
</li>
<li><a href="#org7367e0b">4. Metodología de pruebas</a>
<ul>
<li><a href="#org12441c4">4.1. Set up para recolección y visualización de datos</a>
<ul>
<li><a href="#org55c5164">4.1.1. Graphit + Grafana + StatsD (métricas custom)</a></li>
<li><a href="#orgf458e18">4.1.2. DataDog (logs + métricas etiquetadas)</a></li>
<li><a href="#orga6552d9">4.1.3. DataDog (dashboard)</a></li>
</ul>
</li>
<li><a href="#orgdf0f801">4.2. Generación de carga</a></li>
<li><a href="#org65d9ea0">4.3. Graficos</a></li>
</ul>
</li>
<li><a href="#org810c56c">5. Resultados empíricos – Caso base</a>
<ul>
<li><a href="#orgddcce31">5.1. Prueba con carga baja</a>
<ul>
<li><a href="#orgf2ca716">5.1.1. Análisis del endpoint GET Rates</a></li>
<li><a href="#org65660f2">5.1.2. Análisis del endpoint PUT rates</a></li>
<li><a href="#orgebaa475">5.1.3. Análisis del endpoint POST exchange</a></li>
</ul>
</li>
<li><a href="#orgc997398">5.2. Prueba con carga alta</a>
<ul>
<li><a href="#org2a5b5fb">5.2.1. Análisis del endpoint GET Rates</a></li>
<li><a href="#orgbfe6c52">5.2.2. Análisis del endpoint PUT rates</a></li>
<li><a href="#orga40bf67">5.2.3. Análisis del endpoint POST exchange</a></li>
<li><a href="#org94d3369">5.2.4. Consumo de recursos del balanceador de carga</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfb91843">6. Propuestas de mejora</a>
<ul>
<li><a href="#org4d6bccb">6.1. Implementación de Valkey como persistencia</a>
<ul>
<li><a href="#org8cf406d">6.1.1. Táctica aplicada</a></li>
<li><a href="#org09b5ccf">6.1.2. Configuración</a></li>
<li><a href="#org883c4a0">6.1.3. Beneficios</a></li>
</ul>
</li>
<li><a href="#orgecc74a9">6.2. Implementación de PostgreSQL como persistencia</a>
<ul>
<li><a href="#org36a91e6">6.2.1. Táctica aplicada</a></li>
<li><a href="#org7f2e2f7">6.2.2. Configuración</a></li>
<li><a href="#org9133ed2">6.2.3. Beneficios</a></li>
</ul>
</li>
<li><a href="#org9d9a438">6.3. Comparación de estados de requests</a></li>
</ul>
</li>
<li><a href="#orgf89edee">7. Resultados empíricos- Propuestas de mejora</a>
<ul>
<li><a href="#org6d06734">7.1. Propuesta - Valkey/Redis</a>
<ul>
<li><a href="#org12b5a21">7.1.1. Rates</a></li>
<li><a href="#orgec08780">7.1.2. Exchange</a></li>
</ul>
</li>
<li><a href="#org3f9993e">7.2. Propuesta - PostgreSQL y balanceo de carga efectivo</a></li>
</ul>
</li>
<li><a href="#org098a9c1">8. Trade-offs detectados.</a></li>
<li><a href="#org486d532">9. Pedido Adicional (Volumen de transacciones por moneda)</a></li>
<li><a href="#orgb7fd1b0">10. Conclusiones</a></li>
</ul>
</div>
</div>
<div id="outline-container-org9703863" class="outline-2">
<h2 id="org9703863"><span class="section-number-2">1.</span> Introducción</h2>
<div class="outline-text-2" id="text-1">
<p>
arVault es una startup fintech que opera una billetera digital con un enfoque en ofrecer tasas de cambio competitivas para operaciones entre distintas monedas. En un contexto donde la confianza del usuario es fundamental, la empresa se enfrenta al desafío de mejorar su servicio de cambio de divisas tras recibir múltiples reclamos por problemas de rendimiento y disponibilidad.
</p>

<p>
El presente trabajo se enmarca en la necesidad de arVault de realizar una auditoría exhaustiva de su arquitectura actual para identificar oportunidades de mejora en los atributos de calidad del sistema. Este análisis resulta crucial para la empresa, ya que su capacidad de atraer nuevas inversiones depende directamente de la confiabilidad y desempeño de su plataforma.
</p>

<p>
Los objetivos principales de este trabajo práctico son:
</p>

<ol class="org-ol">
<li>Analizar la arquitectura actual del sistema de cambio de divisas.</li>
<li>Identificar los atributos de calidad críticos para el negocio.</li>
<li>Evaluar el impacto de las decisiones de diseño en dichos atributos.</li>
<li>Proponer e implementar mejoras basadas en tácticas arquitectónicas.</li>
<li>Medir y comparar el rendimiento antes y después de las modificaciones.</li>
</ol>

<p>
El alcance del análisis abarca tanto aspectos técnicos como de negocio, considerando la infraestructura existente (Node.js, Express, Nginx, etc) y las herramientas de monitoreo implementadas (cAdvisor, StatsD, Graphite, Grafana). Se prestará especial atención a métricas clave como el volumen de operaciones por moneda y el neto de transacciones, tal como lo solicitó el fundador de arVault.
</p>

<p>
Este informe documenta nuestro proceso de análisis, las decisiones tomadas y los resultados obtenidos, con el fin de proporcionar recomendaciones fundamentadas que permitan a arVault mejorar la calidad de su servicio y recuperar la confianza de sus usuarios e inversores.
</p>
</div>
</div>
<div id="outline-container-org3d9609b" class="outline-2">
<h2 id="org3d9609b"><span class="section-number-2">2.</span> Atributos de calidad (QA) claves identificados</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgfde1294" class="outline-3">
<h3 id="orgfde1294"><span class="section-number-3">2.1.</span> Disponibilidad</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Al tratarse de un servicio de intercambio de monedas, se considera que su utilización se concentra principalmente durante los días hábiles y en horario cambiario. En consecuencia, es fundamental garantizar su disponibilidad en dichos períodos para evitar la pérdida de usuarios o transacciones.
</p>

<p>
Asimismo, teniendo en cuenta la necesidad de recuperar la confianza de los usuarios y mejorar la reputación del servicio, el sistema debe ofrecer altos niveles de accesibilidad y permitir la ejecución correcta de las operaciones, manteniendo tiempos de respuesta adecuados y consistentes.
</p>
</div>
</div>
<div id="outline-container-org526a6d0" class="outline-3">
<h3 id="org526a6d0"><span class="section-number-3">2.2.</span> Escalabilidad (Elasticidad)</h3>
<div class="outline-text-3" id="text-2-2">
<p>
La escalabilidad, y en particular la elasticidad, constituyen un atributo de calidad fundamental para el servicio de intercambio de divisas. Esto se debe a que la infraestructura del sistema debe poder adaptarse dinámicamente a las variaciones en la demanda de uso.
</p>

<p>
En el contexto operativo, es previsible la aparición de picos significativos de actividad en momentos determinados, como la apertura y cierre del horario cambiario, así como también períodos de menor o nula demanda. Además, dado que el servicio busca incrementar rápidamente su base de usuarios, especialmente tras campañas orientadas a mejorar su percepción pública, existe el riesgo de enfrentar incrementos inesperados en el volumen de tráfico.
</p>

<p>
Si el sistema no contara con la capacidad de escalar de forma elástica, estos picos de operaciones podrían provocar saturación de recursos, generando demoras, rechazos de transacciones o interrupciones del servicio. Tales incidentes impactarían directamente en la percepción y confianza de los usuarios, aspectos clave para el cumplimiento de los objetivos estratégicos de la organización.
</p>
</div>
</div>
<div id="outline-container-org9b63f96" class="outline-3">
<h3 id="org9b63f96"><span class="section-number-3">2.3.</span> Performance</h3>
<div class="outline-text-3" id="text-2-3">
<p>
El atributo de calidad <b><b>Rendimiento</b></b>, y en particular el <b><b>Rendimiento Percibido por el Usuario</b></b>, resulta de relevancia crítica para el servicio de intercambio de divisas. Esta afirmación se sustenta en el análisis del contexto y los antecedentes disponibles.
</p>

<p>
Luego del lanzamiento de la funcionalidad, se detectaron reportes de demoras y fallas en la ejecución de operaciones, lo que generó comentarios negativos y una disminución en la confianza hacia la plataforma. En un escenario donde la organización busca atraer nuevas rondas de inversión, estas limitaciones de rendimiento constituyen un riesgo relevante, dado que los potenciales inversores han condicionado su apoyo a la mejora en la calidad del servicio.
</p>

<p>
En aplicaciones de carácter financiero, la percepción de agilidad y confiabilidad en las respuestas del sistema es un factor determinante. Tiempos de espera prolongados o transacciones fallidas afectan de manera directa la experiencia de las personas usuarias y la credibilidad del sistema. Aunque el valor diferencial del servicio radica en ofrecer tasas de cambio competitivas, dicho beneficio pierde relevancia si la aplicación no responde con la rapidez y estabilidad esperadas.
</p>

<p>
Por lo tanto, la optimización del Rendimiento Percibido por el Usuario se plantea como una acción prioritaria, orientada a recuperar la confianza de los usuarios actuales, fortalecer la reputación institucional y favorecer la atracción de nuevas inversiones, asegurando la continuidad y el crecimiento del servicio.
</p>
</div>
</div>
<div id="outline-container-org05491ff" class="outline-3">
<h3 id="org05491ff"><span class="section-number-3">2.4.</span> Visibilidad</h3>
<div class="outline-text-3" id="text-2-4">
<p>
El valor de este atributo de calidad es más indirecto, pero estratégico, ya que permite comprender el comportamiento real del sistema, identificar cuellos de botella en el rendimiento, localizar errores en las operaciones de cambio y detectar patrones de saturación que puedan anticipar problemas de disponibilidad o escalabilidad. En otras palabras, aunque la visibilidad no impacta de manera inmediata en la experiencia del usuario, proporciona a los arquitectos y al equipo técnico la información necesaria para diagnosticar, mejorar y mantener otros atributos de calidad prioritarios del sistema.
</p>
</div>
</div>
</div>
<div id="outline-container-orge4f5ffc" class="outline-2">
<h2 id="orge4f5ffc"><span class="section-number-2">3.</span> Arquitectura base</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org8932e19" class="outline-3">
<h3 id="org8932e19"><span class="section-number-3">3.1.</span> Análisis de la influencia de decisiones de diseño en los QA's</h3>
<div class="outline-text-3" id="text-3-1">
<p>
En la presente sección se explorarán las decisiones de diseño identificadas en la arquitectura base y su impacto sobre los atributos de calidad estudiados.
</p>
</div>
</div>
<div id="outline-container-orge1ba04b" class="outline-3">
<h3 id="orge1ba04b"><span class="section-number-3">3.2.</span> Incorporación del stack de monitoreo cAdvisor + Artillery + StatsD + Graphite + Grafana</h3>
<div class="outline-text-3" id="text-3-2">
<p>
El sistema actual presenta un stack de observabilidad para medir, almacenar y visualizar métricas en tiempo real. En concreto:
</p>
<ul class="org-ul">
<li>cAdvisor: mide métricas de contenedores (CPU, memoria, etc.)</li>
<li>Artillery: genera carga (testing de rendimiento)</li>
<li>StatsD + Graphite: recolectan y almacenan métricas</li>
<li>Grafana: visualiza las métricas</li>
</ul>

<p>
Esta decisión implicó agregar tres nuevos contenedores, configuraciones adicionales, puertos, conexiones en red internas de Docker y dependencias entre servicios, lo cual impactó de diferentes formas a distintos <b>stakeholders</b>.
</p>
</div>
<div id="outline-container-org1dabab8" class="outline-4">
<h4 id="org1dabab8"><span class="section-number-4">3.2.1.</span> Impactos identificados</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li><b>Carga cognitiva alta:</b>
Implicó que desarrolladores y arquitectos del sistema deban comprender cómo se conectan las herramientas, qué hace cada una y cómo interpretar los datos generados.
Esto impacta la <b>usabilidad interna</b> (para el desarrollador), la <b>manejabilidad</b> y la <b>simplicidad</b> del sistema, que originalmente se componía solo de un backend y un proxy inverso (Nginx).</li>

<li><b>Complejidad operativa:</b>
Más contenedores implican más puertos, configuraciones y <b>logs</b> extensos (en particular en el entorno local del trabajo práctico), lo cual aumenta el esfuerzo de <b>debugging</b> y de gestión general.
Esto afecta negativamente la <b>manejabilidad</b>, dado que se incrementa la complejidad operativa y el tiempo requerido para mantener el sistema.</li>

<li><b>Evaluación y visibilidad del comportamiento del sistema:</b>
Cuando el stack se encuentra correctamente configurado, las métricas permiten monitorear el rendimiento, detectar cuellos de botella y observar cómo interactúan los distintos componentes.
Esto mejora la <b>visibilidad</b> del sistema y favorece la <b>confiabilidad</b>, ya que permite anticipar fallos o anomalías de comportamiento.
No obstante, la dependencia entre múltiples herramientas introduce el riesgo de obtener una visibilidad incompleta si alguno de los servicios del stack (por ejemplo, Graphite o StatsD) deja de funcionar.</li>

<li><b>Afectación a la disponibilidad:</b>
El aumento en la cantidad de servicios dependientes implica más puntos de falla. Si Graphite o StatsD se detienen, Grafana dejará de mostrar información actualizada.
Además, el tiempo de despliegue y recuperación ante fallos se incrementa, afectando la <b>disponibilidad</b> de manera negativa, sobre todo en entornos locales.</li>

<li><b>Apoyo a la testeabilidad y diagnóstico:</b>
El stack de monitoreo potencia la capacidad de análisis durante pruebas de rendimiento (por ejemplo, al utilizar Artillery y observar las métricas en Grafana).
Esto facilita la identificación de comportamientos anómalos y la validación de la estabilidad del sistema, mejorando la <b>testeabilidad</b>.
Sin embargo, la infraestructura adicional necesaria para habilitar el monitoreo también introduce complejidad en el entorno de prueba, lo que puede dificultar la reproducibilidad y el control de los experimentos.</li>

<li><b>Seguridad y aislamiento:</b>
Añadir más servicios amplía la superficie de ataque, ya que cada contenedor es un proceso escuchando en distintos puertos internos.
Esto impacta la <b>seguridad operativa</b>, aunque su efecto sea poco relevante en entornos locales de desarrollo.</li>

<li><b>Impacto en la portabilidad del sistema:</b>
La containerización permite desplegar el stack completo en distintos entornos con relativa facilidad, lo cual favorece la <b>portabilidad técnica</b>.
Sin embargo, la fuerte interdependencia entre servicios y las configuraciones específicas de red, puertos y volúmenes reducen la <b>portabilidad práctica</b>, dado que pequeñas diferencias en la infraestructura pueden afectar el funcionamiento o requerir ajustes manuales.</li>

<li><b>Interoperabilidad y acoplamiento tecnológico:</b>
El uso de protocolos y herramientas estandarizadas (UDP, HTTP, Grafana, StatsD) favorece la <b>interoperabilidad</b> del sistema, tanto entre sus propios componentes como con futuras herramientas externas de monitoreo.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9060e73" class="outline-3">
<h3 id="org9060e73"><span class="section-number-3">3.3.</span> Impactos del modelo de persistencia elegido</h3>
<div class="outline-text-3" id="text-3-3">
<p>
El modelo de persistencia implementado en el sistema consiste en mantener en memoria el estado de los datos y, periódicamente, volcar dicho estado a archivos JSON almacenados localmente en la carpeta <code>~/state/~</code>.
Esto implica que la persistencia está acoplada directamente a la instancia del servidor —es decir, se trata de un sistema *stateful*—, lo que conlleva una serie de consecuencias relevantes sobre diversos atributos de calidad.
</p>

<ul class="org-ul">
<li><b>Acoplamiento con la instancia del servidor:</b>
Al vincular el estado con una única instancia, las sesiones de usuario y los datos persistentes no pueden compartirse entre instancias.
Esto impide la <b>escalabilidad horizontal</b>, dado que cada réplica tendría su propio estado local no sincronizado. Implementar una gestión de estado distribuido requeriría una infraestructura adicional (por ejemplo, una base de datos externa o un servicio de caché compartido).</li>

<li><b>Impacto en la disponibilidad y rendimiento percibido:</b>
La existencia de una única instancia con estado convierte al backend en un <b>punto único de falla</b>.
Si el servidor se detiene, todas las sesiones activas se pierden y no pueden ser recuperadas por otra instancia.
Esto afecta la <b>disponibilidad</b> y la <b>experiencia del usuario</b>, ya que aumenta la percepción de fallas y degradación del rendimiento.</li>

<li><b>Problemas de concurrencia:</b>
Al utilizar el sistema de archivos local como medio de persistencia, se introducen <b>condiciones de carrera</b> durante operaciones de lectura y escritura concurrentes.
El modelo de concurrencia de Node.js (basado en asincronía) no resulta suficiente para garantizar consistencia, dado que el file system no ofrece bloqueo ni sincronización de accesos concurrentes.
Esto impacta negativamente la <b>confiabilidad</b> y la <b>consistencia de datos</b>.</li>

<li><b>Ausencia de soporte transaccional:</b>
El modelo carece de transacciones, por lo que las operaciones no son atómicas ni recuperables ante fallos.
En caso de interrupciones durante la escritura, el sistema puede quedar en estados inconsistentes o requerir restauraciones manuales.
Esto degrada tanto la <b>disponibilidad</b> como la <b>recuperabilidad</b>.</li>

<li><b>Pérdida de integridad de datos:</b>
La falta de atomicidad en las operaciones puede dejar al sistema en estados inválidos (por ejemplo, inconsistencias en saldos o cantidades totales).
En consecuencia, la <b>integridad</b> del sistema se ve directamente comprometida.</li>

<li><b>Incompatibilidad con balanceo de carga:</b>
Dado que el modelo de persistencia no soporta replicación, la existencia de un balanceador de carga (como Nginx) se vuelve una decisión cuestionable.
No existen múltiples backends entre los cuales distribuir tráfico, y el balanceador introduce una capa de comunicación adicional que <b>degrada el rendimiento</b> sin aportar beneficios reales.</li>
</ul>

<p>
En conjunto, este modelo de persistencia afecta negativamente la <b>disponibilidad</b>, la <b>escalabilidad</b>, la <b>integridad</b> y la <b>mantenibilidad</b>, al tiempo que incrementa la <b>complejidad operativa</b> y el riesgo de errores durante la evolución del sistema.
</p>
</div>
</div>
<div id="outline-container-org15f0a9b" class="outline-3">
<h3 id="org15f0a9b"><span class="section-number-3">3.4.</span> Instancias únicas de cada servicio</h3>
<div class="outline-text-3" id="text-3-4">
<p>
El sistema fue diseñado de manera que cada servicio (API, proxy inverso Nginx, almacenamiento local, etc.) cuenta con una única instancia activa.
Esta decisión genera <b>múltiples puntos únicos de falla</b> y limita severamente la capacidad del sistema para mantener su operación ante fallos parciales.
</p>

<ul class="org-ul">
<li>Si cualquiera de estos servicios se detiene, el sistema completo se vuelve <b>indisponible</b>, afectando directamente la <b>disponibilidad</b> y la <b>tolerancia a fallos</b>.</li>
<li>La ausencia de mecanismos automáticos de recuperación o reinicio (como <b>health checks</b>, <b>watchdogs</b> o políticas de <b>restart</b> configuradas en Docker) agrava el impacto de las fallas, ya que se requiere intervención manual para restablecer el servicio.</li>
<li>Tampoco existen estrategias de <b>replicación</b>, <b>balanceo</b> ni <b>redundancia</b>, lo que hace imposible sostener niveles de servicio adecuados bajo carga o ante degradación de componentes.</li>
</ul>

<p>
Esta configuración puede ser suficiente para entornos de desarrollo o demostración, pero resulta <b>inadecuada para entornos de producción</b>, donde la <b>disponibilidad</b>, <b>resiliencia</b> y <b>recuperabilidad</b> son atributos esenciales.
</p>
</div>
</div>
<div id="outline-container-org24dc452" class="outline-3">
<h3 id="org24dc452"><span class="section-number-3">3.5.</span> Ausencia de un patrón de arquitectura interna</h3>
<div class="outline-text-3" id="text-3-5">
<p>
El sistema carece de un patrón de arquitectura claramente definido a nivel interno (por ejemplo, MVC, capas o microservicios), lo cual genera una estructura <b>monolítica y fuertemente acoplada</b>.
Esta decisión afecta negativamente atributos clave del sistema relacionados con su evolución y mantenibilidad.
</p>

<ul class="org-ul">
<li><b>Dificultad para modificar o extender funcionalidades:</b>
La ausencia de separación de responsabilidades y de interfaces desacopladas complica la incorporación de nuevas funcionalidades (<b>extensibilidad</b>) o la modificación segura de las existentes (<b>modificabilidad</b>).</li>

<li><b>Incremento en la complejidad del código:</b>
La lógica de negocio, de presentación y de persistencia tienden a mezclarse, lo que eleva la <b>complejidad cognitiva</b> y el riesgo de introducir errores.</li>

<li><b>Falta de testabilidad:</b>
Al no existir módulos claramente delimitados, las pruebas unitarias o de integración se vuelven difíciles de implementar, afectando la <b>testeabilidad</b> del sistema.</li>

<li><b>Escasa capacidad de evolución:</b>
La arquitectura monolítica limita la posibilidad de migrar gradualmente a tecnologías más modernas o de reestructurar componentes de forma incremental.</li>
</ul>

<p>
En conjunto, esta ausencia de estructura arquitectónica limita la <b>mantenibilidad</b>, <b>evolutividad</b>, <b>testeabilidad</b> y <b>extensibilidad</b>, dificultando la gestión del ciclo de vida del software.
</p>
</div>
</div>
<div id="outline-container-org41f07ef" class="outline-3">
<h3 id="org41f07ef"><span class="section-number-3">3.6.</span> Diagrama C&amp;C inicial.</h3>
<div class="outline-text-3" id="text-3-6">

<div id="org26609a0" class="figure">
<p><img src="assets/componentes.png" alt="componentes.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgc8913f2" class="outline-3">
<h3 id="orgc8913f2"><span class="section-number-3">3.7.</span> Crítica a arquitectura base.</h3>
</div>
</div>
<div id="outline-container-org7367e0b" class="outline-2">
<h2 id="org7367e0b"><span class="section-number-2">4.</span> Metodología de pruebas</h2>
<div class="outline-text-2" id="text-4">
<p>
Con el propósito de realizar pruebas y tener una medición de los atributos de calidad relevantes del sistema, se realizaron pruebas de carga sobre la aplicación mediante la herramienta Artillery y junto con StatsD, Graphite, Grafana y Datadog, se realiza la recolección y visualización de los datos de desempeño, incluyendo métricas como tiempos de respuesta, errores y uso de recursos, lo que permite evaluar la capacidad del sistema para manejar diferentes niveles de carga y detectar posibles cuellos de botella.
</p>
</div>
<div id="outline-container-org12441c4" class="outline-3">
<h3 id="org12441c4"><span class="section-number-3">4.1.</span> Set up para recolección y visualización de datos</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org55c5164" class="outline-4">
<h4 id="org55c5164"><span class="section-number-4">4.1.1.</span> Graphit + Grafana + StatsD (métricas custom)</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
En la app se agregaron métricas propias con <code>hot-shots</code> (cliente StatsD/DogStatsD) usando el prefijo <code>arvault.</code>. Se emiten en dos puntos: (a) middleware HTTP para latencia y throughput, y (b) lógica de negocio del exchange para volumen y estado de las operaciones.
</p>

<ul class="org-ul">
<li>HTTP (Performance)
<ul class="org-ul">
<li><code>arvault.api.response_time</code> (<b>timing</b>, ms): latencia por request medida en el middleware. Útil para ver p50/p95/p99 y detectar degradaciones bajo carga.</li>
<li><code>arvault.api.requests</code> (<b>counter</b>): throughput de la API. Sirve para correlacionar picos de tráfico con cambios en latencia y calcular tasas (p. ej., error rate).</li>
</ul></li>

<li>Negocio (Visibilidad, Disponibilidad proxy)
<ul class="org-ul">
<li><code>arvault.exchange.transactions</code> (<b>counter</b>): total de operaciones de intercambio. Base para segmentar por par de monedas y estado.
<ul class="org-ul">
<li><code>arvault.exchange.successful_transactions</code> (<b>counter</b>): operaciones exitosas; permite estimar disponibilidad efectiva percibida.</li>
<li><code>arvault.exchange.failed_transactions</code> (<b>counter</b>): operaciones fallidas; se usa con la anterior para ver el ratio de fallas.</li>
</ul></li>
<li><code>arvault.exchange.base_amount</code> / <code>arvault.exchange.counter_amount</code> (<b>gauge</b>): montos de la operación en moneda base y contraparte. Ayudan a entender volumen económico y detectar outliers.</li>
<li><code>arvault.exchange.rate</code> (<b>gauge</b>): tasa aplicada al momento del intercambio. Útil para auditar cambios de precio y drift respecto de configuraciones.</li>
<li><code>arvault.volume.by_currency</code> (<b>gauge</b>): volumen por <code>currency</code> y <code>operation</code> (<code>buy/sell</code>). Indica monedas demandadas y patrones de demanda.</li>
<li><code>arvault.volume.operations_count</code> (<b>counter</b>): cantidad de operaciones por dimensión de volumen; complementa el gauge para ver frecuencia sin importar el monto.</li>
<li><code>arvault.volume.net</code> (<b>gauge</b>): balance neto por moneda (positivo en <code>buy</code>, negativo en <code>sell</code>). Sirve para monitorear exposición neta / liquidez.</li>
<li><code>arvault.account.balance</code> (<b>gauge</b>): balances reportados por cuenta/moneda. Útil para verificar disponibilidad de fondos y umbrales operativos.</li>
</ul></li>

<li>Errores (Confiabilidad)
<ul class="org-ul">
<li><code>arvault.errors.count</code> (<b>counter</b>)</li>
</ul></li>
</ul>

<p>
Las métricas incluyen <b>tags</b> según el caso (p. ej., <code>endpoint</code>, <code>method</code>, <code>status_code</code>, <code>currency</code>, <code>operation</code>, <code>base_currency</code>, <code>counter_currency</code>, <code>success</code>, y metadatos globales <code>service</code>, <code>env</code>). Estas señales se usan luego para contrastar escenarios de carga y fundamentar observaciones sobre <b><b>Performance</b></b>, <b><b>Disponibilidad</b></b> y <b><b>Visibilidad</b></b>.
</p>
</div>
</div>
<div id="outline-container-orgf458e18" class="outline-4">
<h4 id="orgf458e18"><span class="section-number-4">4.1.2.</span> DataDog (logs + métricas etiquetadas)</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
Se habilitó <b><b>logging estructurado</b></b> y el envío de <b><b>métricas etiquetadas</b></b> compatibles con DogStatsD.
</p>

<ul class="org-ul">
<li>Logs JSON con <code>winston</code>
<ul class="org-ul">
<li>Formato: <code>timestamp</code>, captura de <code>errors({ stack: true })</code>, y <code>defaultMeta</code> (<code>service</code>, <code>env</code>, <code>version</code>).</li>
<li>Registros implementados:
<ul class="org-ul">
<li><code>logRequest</code>: método, URL/path, <code>status_code</code>, <code>response_time</code>, <code>user_agent</code>, IP, <code>request_id</code>.</li>
<li><code>logValidationError</code>: errores de entrada (tipo, mensaje, <code>endpoint</code>, <code>request_data</code>).</li>
<li><code>logSystemError</code>: fallas internas (mensaje, <code>stack</code>, nombre de error, <code>context</code>).</li>
<li><code>logExchangeTransaction</code>: resultado de intercambio (ok/falla), IDs de cuentas, monedas, montos, <code>exchange_rate</code>, mensaje de error si aplica.</li>
<li><code>logPerformance</code>: duración de operaciones puntuales.</li>
<li><code>logLifecycleEvent</code>: eventos de ciclo de vida (ej., <code>startup</code>).</li>
</ul></li>
</ul></li>

<li>Métricas con <b>tags</b> (DogStatsD)
<ul class="org-ul">
<li>Las métricas <code>arvault.*</code> anteriores se envían con <b>tags</b> (p. ej., <code>endpoint</code>, <code>method</code>, <code>status_code</code>, <code>currency</code>, <code>operation</code>, <code>base_currency</code>, <code>counter_currency</code>, <code>success</code>, además de <code>service</code>, <code>env</code>, <code>version</code>).</li>
<li>Esto permite segmentar los indicadores de <b><b>Performance</b></b> y <b><b>Visibilidad</b></b> por dimensiones de negocio y técnicas.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga6552d9" class="outline-4">
<h4 id="orga6552d9"><span class="section-number-4">4.1.3.</span> DataDog (dashboard)</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
Armamos un dashboard simple para entender las fallas criticas del servicio y ademas entender el dominio del negocio. La idea es cubrir tres frentes a la vez: <b><b>Performance</b></b> (qué tan rápido respondemos), <b><b>Disponibilidad/Confiabilidad</b></b> (qué tan seguido falla) y <b><b>Visibilidad</b></b> (qué parte del negocio está más activa).
</p>
</div>
<ol class="org-ol">
<li><a id="org0c92204"></a>Requests per endpoint<br />
<div class="outline-text-5" id="text-4-1-3-1">
<p>
Cuántas llamadas recibe cada ruta. Con esto vemos cuáles son las más usadas y dónde conviene poner foco de capacidad.
</p>

<div id="org9b3ff1c" class="figure">
<p><img src="assets/db-02-requests-by-endpoint.png" alt="db-02-requests-by-endpoint.png" />
</p>
<p><span class="figure-number">Figura 1: </span>Requests por endpoint</p>
</div>
</div>
</li>
<li><a id="org2038997"></a>Status Codes Distribution<br />
<div class="outline-text-5" id="text-4-1-3-2">
<p>
La mezcla de 200/4xx/5xx a lo largo del tiempo. Es nuestro termómetro de salud: muchos 5xx = algo se rompió del lado servidor; pico de 4xx = validaciones/UX para revisar.
</p>

<div id="org08fab37" class="figure">
<p><img src="assets/db-03-status-codes.png" alt="db-03-status-codes.png" />
</p>
<p><span class="figure-number">Figura 2: </span>Distribución de status codes</p>
</div>
</div>
</li>
<li><a id="org7bc488e"></a>Exchange – Success rate<br />
<div class="outline-text-5" id="text-4-1-3-3">
<p>
Porcentaje de transacciones que salen bien vs. fallan. Cuando baja, impacta directo al negocio y hay que mirar lógica y dependencias.
</p>

<div id="org5155259" class="figure">
<p><img src="assets/db-04-exchange-success-rate.png" alt="db-04-exchange-success-rate.png" />
</p>
<p><span class="figure-number">Figura 3: </span>Tasa de éxito de transacciones de exchange</p>
</div>
</div>
</li>
<li><a id="org2e8a508"></a>Exchange – Total transactions<br />
<div class="outline-text-5" id="text-4-1-3-4">
<p>
Volumen bruto de operaciones. Útil para ver actividad, comparar días y estimar capacidad necesaria.
</p>

<div id="org64984c6" class="figure">
<p><img src="assets/db-05-exchange-total.png" alt="db-05-exchange-total.png" />
</p>
<p><span class="figure-number">Figura 4: </span>Total de transacciones de exchange</p>
</div>
</div>
</li>
<li><a id="orge821250"></a>Volume by currency<br />
<div class="outline-text-5" id="text-4-1-3-5">
<p>
Cuánta actividad concentra cada moneda (USD, ARS, EUR, …). Ayuda con liquidez y prioridades: dónde hay más movimiento, ahí hay más riesgo/atención.
</p>

<div id="orgae705d0" class="figure">
<p><img src="assets/db-06-volume-by-currency.png" alt="db-06-volume-by-currency.png" />
</p>
<p><span class="figure-number">Figura 5: </span>Volumen por moneda</p>
</div>
</div>
</li>
<li><a id="orgf9c9d20"></a>Net volume by currency<br />
<div class="outline-text-5" id="text-4-1-3-6">
<p>
Compras menos ventas por moneda. Si el neto de USD es muy negativo, estamos vendiendo más de lo que compramos: ojo con la posición.
</p>

<div id="orgaf726ad" class="figure">
<p><img src="assets/db-07-net-volume-by-currency.png" alt="db-07-net-volume-by-currency.png" />
</p>
<p><span class="figure-number">Figura 6: </span>Volumen neto por moneda</p>
</div>
</div>
</li>
<li><a id="orgc9511e6"></a>Exchange rates<br />
<div class="outline-text-5" id="text-4-1-3-7">
<p>
Las tasas vigentes por par. Sirve para chequear precios, detectar volatilidad y cuidar márgenes.
</p>

<div id="org4a46963" class="figure">
<p><img src="assets/db-08-exchange-rates.png" alt="db-08-exchange-rates.png" />
</p>
<p><span class="figure-number">Figura 7: </span>Tasas de cambio por par</p>
</div>
</div>
</li>
<li><a id="orgee25b49"></a>Error count por tipo<br />
<div class="outline-text-5" id="text-4-1-3-8">
<p>
Los errores agrupados por categoría (p. ej., <code>validation_error</code>, <code>exchange_failed</code>). Da pista rápida de dónde conviene atacar: UX/validaciones o lógica interna.
</p>

<div id="orged3304e" class="figure">
<p><img src="assets/db-10-error-count-by-type.png" alt="db-10-error-count-by-type.png" />
</p>
<p><span class="figure-number">Figura 8: </span>Conteo de errores por tipo</p>
</div>
</div>
</li>
<li><a id="org688d14e"></a>KPIs de resumen<br />
<div class="outline-text-5" id="text-4-1-3-9">
<p>
Un par de tarjetas con lo esencial: throughput, total de transacciones y total de errores. Es la vista “de un vistazo” para status diario y alertas.
</p>

<div id="orgbc43748" class="figure">
<p><img src="assets/db-12-15-summary-kpis.png" alt="db-12-15-summary-kpis.png" />
</p>
<p><span class="figure-number">Figura 9: </span>KPIs de resumen (requests, transacciones, errores)</p>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-orgdf0f801" class="outline-3">
<h3 id="orgdf0f801"><span class="section-number-3">4.2.</span> Generación de carga</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Con propósito de observar la aplicación se generaron diferentes escenarios de carga, uno de baja carga con el propósito de observar el comportamiento de la API en un momento de uso con baja intensidad y otro de uso con alta intensidad representando los posibles escenarios en los que se encuentre la aplicación en producción. 
</p>

<p>
Los escenarios se aplicarán a cada uno de los endpoints, si es un endpoint GET, se generan muchas consultas a la API por el mismo endpoint, mientras que en casos de PUT se interactúa con las distintas monedas generando una carga más variada y simulando una situación lo más realista posible.
</p>

<p>
Los patrones son los siguientes:
</p>

<p>
Para una carga y observar un comportamiento genérico de la app:
</p>

<div class="org-src-container">
<pre class="src src-yaml">phases:
  - name: Ramp
    duration: 30
    arrivalRate: 1
    rampTo: 5
  - name: Plain
    duration: 60
    arrivalRate: 5
</pre>
</div>

<p>
Mientras que para uso intensivo de la aplicación se usa el mismo patrón pero variando los valores:
</p>


<div class="org-src-container">
<pre class="src src-yaml">phases:
  - name: Ramp
    duration: 30
    arrivalRate: 0
    rampTo: 1000
  - name: Plain
    duration: 60
    arrivalRate: 500
</pre>
</div>

<p>
Por lo tanto ambas cargas serán aplicadas a los endpoints considerando la variabilidad de los datos en el caso que sea necesario
</p>
</div>
</div>
<div id="outline-container-org65d9ea0" class="outline-3">
<h3 id="org65d9ea0"><span class="section-number-3">4.3.</span> Graficos</h3>
<div class="outline-text-3" id="text-4-3">
<p>
En líneas generales se presentan 4 gráficos: 
</p>

<ul class="org-ul">
<li><b><b>Scenarios launched (stacked)</b></b>: Este gráfico muestra los escenarios que se están ejecutando, en caso de ser la prueba de un método GET, no habrá variabilidad en los casos, por otro lado, cuando se trate de un POST o un PUT se podrán apreciar la variabilidad en los escenarios de prueba configurados</li>
<li><b><b>Requests state (stacked)</b></b>: Muestra el estado de las request, se grafican principalmente los escenarios en los cuales la API contesta a la request con un código 200, en algunos casos, se apreciarán la graficación de errores los cuales consideran: <b>ECONNRESET</b> y <b>ETIMEDOUT</b></li>
<li><b><b>Request time (client-side)</b></b>: Que permite obtener una magnitud de la performance del producto como también del tiempo que toma a la aplicación en contestar una request</li>
<li><b><b>Resources</b></b>: Este gráfico permite observar los recursos utilizados por el ordenador tales como: CPU y memoria RAM</li>
</ul>

<p>
Estos gráficos no permiten tener una visibilidad amplia y global sobre el funcionamiento de la aplicación como también entender el comportamiento de los <b>Atributos de calidad</b> claves de la aplicación
</p>
</div>
</div>
</div>
<div id="outline-container-org810c56c" class="outline-2">
<h2 id="org810c56c"><span class="section-number-2">5.</span> Resultados empíricos – Caso base</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgddcce31" class="outline-3">
<h3 id="orgddcce31"><span class="section-number-3">5.1.</span> Prueba con carga baja</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Se procede a presentar los datos de pruebas recolectados en un escenario de baja carga 
</p>
</div>
<div id="outline-container-orgf2ca716" class="outline-4">
<h4 id="orgf2ca716"><span class="section-number-4">5.1.1.</span> Análisis del endpoint GET Rates</h4>
<div class="outline-text-4" id="text-5-1-1">

<div id="org3fcc823" class="figure">
<p><img src="./assets/ratesscenarios.png" alt="ratesscenarios.png" />
</p>
</div>

<p>
Por la simplicidad del endpoint y dada la falta de parámetros que tiene el mismo, el gráfico representa la evolución a través del tiempo de la cantidad de consultas que son realizadas al endpoint
</p>


<div id="orgd50acc6" class="figure">
<p><img src="./assets/ratesstate.png" alt="ratesstate.png" />
</p>
</div>

<p>
De los datos se puede extraer que en un escenario de baja carga de la API, se observa que la totalidad de las consultas fue contestada de manera satisfactoria 
</p>


<div id="org0324608" class="figure">
<p><img src="./assets/ratesresponsetime.png" alt="ratesresponsetime.png" />
</p>
</div>

<p>
De este gráfico se puede extraer información sobre el tiempo de procesamiento y la latencia existente entre el cliente y la aplicación, debido a ser un escenario de pruebas en este caso la latencia es un valor despreciable, mientras que se puede apreciar la evolución del tiempo de procesamiento y se podría considerar la relación existente entre este y la cantidad de request que se encuentra procesando el servidor en el momento
</p>


<div id="org2f3bb79" class="figure">
<p><img src="./assets/ratesresources.png" alt="ratesresources.png" />
</p>
</div>

<p>
Finalmente la cantidad de recursos del ordenador usadas para procesar las consultas no parece ser representativa, se puede concluir que en escenarios de baja intensidad la API responde de manera eficiente y tanto la performance percibida por el usuario como la disponibilidad no se ven afectados en estos escenarios 
</p>
</div>
</div>
<div id="outline-container-org65660f2" class="outline-4">
<h4 id="org65660f2"><span class="section-number-4">5.1.2.</span> Análisis del endpoint PUT rates</h4>
<div class="outline-text-4" id="text-5-1-2">

<div id="org3d07e33" class="figure">
<p><img src="./assets/putratesscenarios.png" alt="putratesscenarios.png" />
</p>
</div>

<p>
Al tratarse de un método PUT, la variabilidad entre los diferentes tipos de monedas utilizadas se puede usar para ejemplificar el funcionamiento en el test, por lo tanto, se puede apreciar que hay una tendencia a realizar cuatro tipos de transacciones diferentes considerando las distintas monedas
</p>


<div id="org6cf6801" class="figure">
<p><img src="./assets/putratesstate.png" alt="putratesstate.png" />
</p>
</div>

<p>
Como en el caso anterior, todas las peticiones al servidor respondieron de manera satisfactoria a los clientes 
</p>


<div id="org533f0c9" class="figure">
<p><img src="./assets/putratesresponsetime.png" alt="putratesresponsetime.png" />
</p>
</div>

<p>
Una vez más se puede apreciar la tendencia a que el uso de recursos (en este caso del CPU) sea más intensivo en el período más temprano en que se realiza el test, es importante aclarar que la recta verde representa los máximos registrados, un valor más parecido al real percibido por el cliente es la media del tiempo de respuesta que también se encuentra en el gráfico
</p>


<div id="org200ca8a" class="figure">
<p><img src="./assets/putratesresources.png" alt="putratesresources.png" />
</p>
</div>

<p>
Nuevamente se observa que no existe un uso excesivo de los recursos del ordenador, por lo tanto, en escenarios de baja intensidad el endpoint contesta de manera satisfactoria a las transacciones 
</p>
</div>
</div>
<div id="outline-container-orgebaa475" class="outline-4">
<h4 id="orgebaa475"><span class="section-number-4">5.1.3.</span> Análisis del endpoint POST exchange</h4>
<div class="outline-text-4" id="text-5-1-3">

<div id="orgd60c7c6" class="figure">
<p><img src="./assets/exchangescenario.png" alt="exchangescenario.png" />
</p>
</div>

<p>
Como en el caso del endpoint anterior, se agrega variabilidad en los escenarios de prueba para simular de manera más realista el escenario de la aplicación que se encuentra en producción, los escenarios están dispuestos que ocurran de manera equiprobable 
</p>


<div id="orgd12d0af" class="figure">
<p><img src="./assets/exchangestatus.png" alt="exchangestatus.png" />
</p>
</div>

<p>
Todos los POST fueron realizados de manera exitosa sin presentar ningún problema en la aplicación 
</p>


<div id="org38932e6" class="figure">
<p><img src="./assets/exchangeresponsetime.png" alt="exchangeresponsetime.png" />
</p>
</div>

<p>
A comparación de los otros endpoints analizados, es evidente que la finalización de esta tarea tiene un orden de magnitud superior a los otros casos, véase que en las pruebas anteriores el máximo de los tiempos de ejecución se encontraba alrededor de los 30 ms mientras que la media se encontraba alrededor de los 20 ms, para este endpoint los tiempos de ejecución se van hasta el rango de los 600 - 800 ms. Esta prueba permite identificar que este endpoint puede ser un posible cuello de botella en un caso de alto volumen de transacciones 
</p>


<div id="org6940c44" class="figure">
<p><img src="./assets/exchangeresources.png" alt="exchangeresources.png" />
</p>
</div>

<p>
Finalmente observando el uso de los recursos del ordenador, se destaca el uso del CPU, para llevar a cabo este conjunto de operaciones el uso del CPU escaló a casi el 1% de su uso. Con este resultado y el anterior es fácil identificar a este endpoint como uno de los posibles casos a considerar para aplicar estrategias en busca de mejorar la performance, esto, pensando a futuro en escenarios de uso intensivo de la aplicación
</p>

<p>
Además de la información anteriormente recolectada, para evitar la repetición sobre la evidencia se descarta la presentación de las pruebas para los otros endpoints, puesto que la información recolectada fue similar y no fue concluyente a la hora de determinar nuevas estrategias arquitectónicas que no puedan ser deducidas de los problemas que fueron encontrados anteriormente en el resto de endpoints
</p>
</div>
</div>
</div>
<div id="outline-container-orgc997398" class="outline-3">
<h3 id="orgc997398"><span class="section-number-3">5.2.</span> Prueba con carga alta</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Se presentan los datos de pruebas recolectados en un escenario de alta carga de la aplicación.
</p>
</div>
<div id="outline-container-org2a5b5fb" class="outline-4">
<h4 id="org2a5b5fb"><span class="section-number-4">5.2.1.</span> Análisis del endpoint GET Rates</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
Las mediciones del comportamiento del sistema (scenarios launched, requests state, request time y resources) en un escenario de alta carga haciendo uso específicamente del endpoint GET rates son las siguientes:
</p>


<div id="orgf81ec1c" class="figure">
<p><img src="./assets/ratesfscenarios.png" alt="ratesfscenarios.png" />
</p>
</div>

<p>
Como en el caso de baja carga y debido a la simplicidad del endpoint en el grafico se aprecian la cantidad de request realizadas por segundo
</p>


<div id="org7e0e64b" class="figure">
<p><img src="./assets/ratesfstate.png" alt="ratesfstate.png" />
</p>
</div>

<p>
Observando el resultado de la prueba se observa que a medida que la carga va creciendo el servidor responde de manera correcta a las consultas realizadas, pero una vez que la cantidad de consultas que van llegando se estabiliza se puede apreciar el inicio del fallo del servidor en la capacidad de contestar a los clientes, estos casos de error que se muestran son tanto errores por timeout como cierre de conexiones inesperadas
</p>


<div id="org65f5417" class="figure">
<p><img src="./assets/ratesfresponsetime.png" alt="ratesfresponsetime.png" />
</p>
</div>

<p>
Tambien se aprecia que a medida que aparecen casos de error los tiempos de respuestas en los clientes empiezan a escalar llegando a alcanzar un pico de casi 10 segundos para conseguir responder a una consulta. Esto es un claro indicio de problemas de performance y de disponibilidad de la aplicacion, atributos que han sido establecidos como clave para esta arquitectura 
</p>


<div id="org609bd1c" class="figure">
<p><img src="./assets/ratesfresources.png" alt="ratesfresources.png" />
</p>
</div>

<p>
Se observa que el modulo de la api no presenta uso excesivo de los recursos del ordenador dada la cantidad de clientes que intentan realizar consultas
</p>
</div>
</div>
<div id="outline-container-orgbfe6c52" class="outline-4">
<h4 id="orgbfe6c52"><span class="section-number-4">5.2.2.</span> Análisis del endpoint PUT rates</h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
Ahora se analiza el endpoint que realiza put de los rates a la API
</p>


<div id="org49b8a9f" class="figure">
<p><img src="./assets/putratesfscenarios.png" alt="putratesfscenarios.png" />
</p>
</div>

<p>
En este gráfico se aprecia la variabilidad de los casos de prueba que se realizaron, ya que el endpoint PUT permite modificar tasas para diferentes pares de monedas. 
</p>


<div id="org94a7a86" class="figure">
<p><img src="./assets/putratesfstate.png" alt="putratesfstate.png" />
</p>
</div>

<p>
Bajo carga alta, se observa que inicialmente todas las requests son procesadas correctamente, pero a medida que aumenta la intensidad, comienzan a aparecer errores de tipo timeout y cierre inesperado de conexiones, similar a lo observado en el endpoint GET. Esto evidencia que el sistema, en su arquitectura base, no logra sostener la disponibilidad y performance cuando la concurrencia crece. 
</p>


<div id="orgf0af272" class="figure">
<p><img src="./assets/putratesfresponsetime.png" alt="putratesfresponsetime.png" />
</p>
</div>

<p>
Similar al endpoint analizado anteriormente nuevamente el tiempo promedio y el tiempo maximo escalan a casi los 10 segundos y los 4 segundos respectivamente, siendo clara evidencia que la disponibilidad y la performance la arquitectura no son capaces de soportar escenarios de carga muy alta por parte de los usuarios
</p>


<div id="orgd3fd3e4" class="figure">
<p><img src="./assets/putratesfresources.png" alt="putratesfresources.png" />
</p>
</div>

<p>
Como en el caso anterior no se observa un uso excesivo de los recursos para el nodo de la api.
</p>
</div>
</div>
<div id="outline-container-orga40bf67" class="outline-4">
<h4 id="orga40bf67"><span class="section-number-4">5.2.3.</span> Análisis del endpoint POST exchange</h4>
<div class="outline-text-4" id="text-5-2-3">

<div id="org12cedbe" class="figure">
<p><img src="./assets/exchangefscenario.png" alt="exchangefscenario.png" />
</p>
</div>

<p>
Se observa la simulación de casos variados de pruebas para el endpoint POST exchange. El análisis de este endpoint es crucial, ya que en el caso de baja carga se observó que dicho endpoint era el más complejo de ejecutar.
</p>


<div id="orga02146c" class="figure">
<p><img src="./assets/exchangefstatus.png" alt="exchangefstatus.png" />
</p>
</div>

<p>
De acuerdo con los datos recolectados, era evidente que para este caso ocurriría una situación similar al realizar la carga en el servidor. Esto se debe a la observación de casos de error por parte de los clientes, similares a los casos evaluados anteriormente.
</p>


<div id="orgade350c" class="figure">
<p><img src="./assets/exchangefresponsetime.png" alt="exchangefresponsetime.png" />
</p>
</div>

<p>
Una vez más, la performance y la disponibilidad del servicio se ven comprometidas y los tiempos de respuesta crecen exponencialmente en escenarios de carga alta, alcanzando también el rango de los 4 a 10 segundos para contestar una respuesta a los clientes por parte del servidor.
</p>


<div id="org874d623" class="figure">
<p><img src="./assets/exchangefresources.png" alt="exchangefresources.png" />
</p>
</div>

<p>
En este caso, sí se aprecia considerablemente el crecimiento en el uso de los recursos, esto se debe tanto a la complejidad en la realización del POST como a la cantidad de operaciones realizadas en un escenario de carga muy alta.
</p>
</div>
</div>
<div id="outline-container-org94d3369" class="outline-4">
<h4 id="org94d3369"><span class="section-number-4">5.2.4.</span> Consumo de recursos del balanceador de carga</h4>
<div class="outline-text-4" id="text-5-2-4">
<p>
Adicionalmente, es interesante observar el consumo de recursos del balanceador de carga que trabaja en conjunto con la API, esto para cada uno de los escenarios intensivos.
Se presenta entonces la recolección de datos sobre el uso de los recursos del computador por parte del balanceador de carga:
</p>


<div id="org26bb48c" class="figure">
<p><img src="./assets/lbexchangefresources.png" alt="lbexchangefresources.png" />
</p>
<p><span class="figure-number">Figura 10: </span>Carga del load balancer para GET Rates</p>
</div>


<div id="org255b240" class="figure">
<p><img src="./assets/lbputratesfresources.png" alt="lbputratesfresources.png" />
</p>
<p><span class="figure-number">Figura 11: </span>Carga del load balancer para PUT Rates</p>
</div>


<div id="org57e2167" class="figure">
<p><img src="./assets/lbexchangefresources.png" alt="lbexchangefresources.png" />
</p>
<p><span class="figure-number">Figura 12: </span>Carga del load balancer para POST Exchange</p>
</div>

<p>
Finalmente, es fácil concluir que el sistema base no posee la capacidad de soportar escenarios de alta carga, comprometiendo la disponibilidad y la performance de un servicio que precisamente busca atraer clientes mediante la mejora de estos atributos de calidad clave.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfb91843" class="outline-2">
<h2 id="orgfb91843"><span class="section-number-2">6.</span> Propuestas de mejora</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org4d6bccb" class="outline-3">
<h3 id="org4d6bccb"><span class="section-number-3">6.1.</span> Implementación de Valkey como persistencia</h3>
<div class="outline-text-3" id="text-6-1">
</div>
<div id="outline-container-org8cf406d" class="outline-4">
<h4 id="org8cf406d"><span class="section-number-4">6.1.1.</span> Táctica aplicada</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
La implementación utiliza Valkey como almacén de datos centralizado, reemplazando la persistencia en archivos JSON. Los datos se almacenan como claves en Redis:
</p>

<ul class="org-ul">
<li><code>accounts</code>: Almacena la lista de cuentas de usuario en formato JSON.</li>
<li><code>rates</code>: Contiene las tasas de cambio entre monedas.</li>
<li><code>log</code>: Registra el historial de transacciones realizadas.</li>
</ul>

<p>
El módulo <code>valkey.js</code> proporciona funciones asíncronas para inicializar la conexión (<code>init()</code>), obtener datos (<code>getAccounts()</code>, <code>getRates()</code>, <code>getLog()</code>) y actualizarlos (<code>setAccounts()</code>, <code>setRates()</code>, <code>setLog()</code>). Estas funciones serializan y deserializan los datos a JSON para almacenarlos como strings en Redis.
</p>

<p>
En <code>exchange.js</code>, se importa y utiliza este módulo para todas las operaciones de persistencia, reemplazando las lecturas y escrituras directas a archivos. La inicialización se realiza al inicio de la aplicación con <code>await valkeyInit()</code>.
</p>
</div>
</div>
<div id="outline-container-org09b5ccf" class="outline-4">
<h4 id="org09b5ccf"><span class="section-number-4">6.1.2.</span> Configuración</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
Se agregó un servicio <code>valkey</code> en el <code>docker-compose.yml</code> utilizando la imagen <code>valkey/valkey:8.1.4-alpine</code>, expuesto en el puerto 6379. La aplicación se conecta mediante la variable de entorno <code>VALKEY_URL=redis://valkey:6379</code>.
</p>
</div>
</div>
<div id="outline-container-org883c4a0" class="outline-4">
<h4 id="org883c4a0"><span class="section-number-4">6.1.3.</span> Beneficios</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
Al centralizar el estado en Valkey, múltiples instancias de la API pueden compartir el mismo almacén de datos. Esto elimina la dependencia de estado local en memoria o archivos, permitiendo:
</p>

<ul class="org-ul">
<li>Escalado horizontal sin pérdida de consistencia.</li>
<li>Persistencia real de los datos, sobreviviente a reinicios de contenedores.</li>
<li>Operaciones atómicas en Redis para transacciones financieras.</li>
</ul>

<p>
Esta táctica mejora significativamente la disponibilidad y escalabilidad, mitigando los puntos únicos de falla relacionados con la persistencia local.
</p>


<div id="orgd854f31" class="figure">
<p><img src="assets/componentes-modificados.png" alt="componentes-modificados.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgecc74a9" class="outline-3">
<h3 id="orgecc74a9"><span class="section-number-3">6.2.</span> Implementación de PostgreSQL como persistencia</h3>
<div class="outline-text-3" id="text-6-2">
</div>
<div id="outline-container-org36a91e6" class="outline-4">
<h4 id="org36a91e6"><span class="section-number-4">6.2.1.</span> Táctica aplicada</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
La implementación utiliza PostgreSQL como almacén de datos relacional, reemplazando la persistencia en archivos JSON y Valkey. Las tablas creadas son:
</p>

<ul class="org-ul">
<li><code>accounts</code>: Almacena las cuentas de usuario con campos como id, currency, balance, created<sub>at</sub>, updated<sub>at</sub>, deleted.</li>
<li><code>exchange_rates</code>: Contiene las tasas de cambio entre monedas con base<sub>currency</sub>, counter<sub>currency</sub>, rate, updated<sub>at</sub>.</li>
<li><code>transactions</code>: Registra el historial de transacciones realizadas, con soporte para atomicidad en operaciones de intercambio.</li>
</ul>

<p>
El módulo <code>databaseAdapter.js</code> proporciona funciones para conectarse a PostgreSQL usando el paquete <code>pg</code>, manejando conexiones y transacciones. Los modelos en <code>models/</code> (Account, ExchangeRate, Transaction) manejan las operaciones CRUD con soporte para transacciones ACID.
</p>

<p>
En <code>exchange.js</code>, se utilizan estos modelos para todas las operaciones financieras, incluyendo transacciones atómicas para intercambios que requieren consistencia (por ejemplo, actualizar balances y registrar la transacción en una sola operación).
</p>
</div>
</div>
<div id="outline-container-org7f2e2f7" class="outline-4">
<h4 id="org7f2e2f7"><span class="section-number-4">6.2.2.</span> Configuración</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
Se agregó un servicio <code>postgres</code> en el <code>docker-compose.yml</code> utilizando la imagen <code>postgres:15-alpine</code>, con inicialización de la base de datos mediante el script <code>01-init.sql</code> que crea las tablas, índices y datos iniciales.
</p>

<p>
Se configuraron tres instancias de la API (<code>api1</code>, <code>api2</code>, <code>api3</code>) conectadas a PostgreSQL, permitiendo escalado horizontal sin pérdida de estado.
</p>

<p>
Se actualizó <code>nginx_reverse_proxy.conf</code> para balancear la carga entre las tres instancias de API utilizando un bloque <code>upstream</code>.
</p>
</div>
</div>
<div id="outline-container-org9133ed2" class="outline-4">
<h4 id="org9133ed2"><span class="section-number-4">6.2.3.</span> Beneficios</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
Al centralizar el estado en PostgreSQL con transacciones ACID, múltiples instancias pueden compartir el mismo almacén de datos de forma consistente y atómica. Esto elimina dependencias de estado local, permite escalado horizontal sin pérdida de consistencia y asegura atomicidad en operaciones financieras críticas, mejorando la integridad de los datos.
</p>

<p>
Esta táctica mejora significativamente la disponibilidad (reduciendo puntos únicos de falla en persistencia), escalabilidad (permitiendo más nodos con estado compartido) y performance (con transacciones eficientes, concurrencia controlada y consultas optimizadas con índices).
</p>


<div id="org633f940" class="figure">
<p><img src="assets/componentes-postgresql.png" alt="componentes-postgresql.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org9d9a438" class="outline-3">
<h3 id="org9d9a438"><span class="section-number-3">6.3.</span> Comparación de estados de requests</h3>
<div class="outline-text-3" id="text-6-3">

<div id="org9334e0a" class="figure">
<p><img src="assets/request-state-base.png" alt="request-state-base.png" />
</p>
<p><span class="figure-number">Figura 13: </span>Estado de requests en la arquitectura base</p>
</div>

<p>
En la arquitectura base, se observa una alta tasa de errores debido a la sobrecarga de la única instancia de la API y problemas de concurrencia en el acceso a archivos JSON locales, lo que resulta en fallos de conexión y respuestas erróneas bajo carga elevada.
</p>


<div id="org1e61407" class="figure">
<p><img src="assets/request-state-postgresql.png" alt="request-state-postgresql.png" />
</p>
<p><span class="figure-number">Figura 14: </span>Estado de requests con la propuesta de mejora (PostgreSQL y balanceo de carga)</p>
</div>

<p>
Con la propuesta de mejora que incluye balanceo de carga entre tres nodos y PostgreSQL como persistencia, la tasa de errores se reduce significativamente. El balanceo de carga distribuye la carga uniformemente entre los nodos, evitando la saturación de un solo punto, mientras que PostgreSQL maneja mejor la concurrencia mediante transacciones ACID y acceso controlado a la base de datos, minimizando errores por conflictos de acceso a datos y mejorando la estabilidad general del sistema.
</p>
</div>
</div>
</div>
<div id="outline-container-orgf89edee" class="outline-2">
<h2 id="orgf89edee"><span class="section-number-2">7.</span> Resultados empíricos- Propuestas de mejora</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org6d06734" class="outline-3">
<h3 id="org6d06734"><span class="section-number-3">7.1.</span> Propuesta - Valkey/Redis</h3>
<div class="outline-text-3" id="text-7-1">
<p>
En las propuestas de mejoras se busca principalmente mejorar la experiencia de los usuarios en escenarios de alta carga sobre la aplicación, dadas las conclusiones resultantes de la sección 5, se analizarán la evolución de las propuestas únicamente en escenarios de alta carga para la aplicación. 
</p>

<p>
Se presentan los resultados de haber integrado Valkey en la aplicación: 
</p>
</div>
<div id="outline-container-org12b5a21" class="outline-4">
<h4 id="org12b5a21"><span class="section-number-4">7.1.1.</span> Rates</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
<img src="./assets/valkey-ratessources.png" alt="valkey-ratessources.png" />
<img src="./assets/valkey-ratesstatus.png" alt="valkey-ratesstatus.png" />
<img src="./assets/valkey-ratesresponsetime.png" alt="valkey-ratesresponsetime.png" />
<img src="./assets/valkey-ratesresources.png" alt="valkey-ratesresources.png" />
</p>
</div>
</div>
<div id="outline-container-orgec08780" class="outline-4">
<h4 id="orgec08780"><span class="section-number-4">7.1.2.</span> Exchange</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
<img src="./assets/valkey-exchangesources.png" alt="valkey-exchangesources.png" />
<img src="./assets/valkey-exchangestatus.png" alt="valkey-exchangestatus.png" />
<img src="./assets/valkey-exchangeresponsetime.png" alt="valkey-exchangeresponsetime.png" />
<img src="./assets/valkey-exchangeresources.png" alt="valkey-exchangeresources.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org3f9993e" class="outline-3">
<h3 id="org3f9993e"><span class="section-number-3">7.2.</span> Propuesta - PostgreSQL y balanceo de carga efectivo</h3>
</div>
</div>
<div id="outline-container-org098a9c1" class="outline-2">
<h2 id="org098a9c1"><span class="section-number-2">8.</span> Trade-offs detectados.</h2>
</div>

<div id="outline-container-org486d532" class="outline-2">
<h2 id="org486d532"><span class="section-number-2">9.</span> Pedido Adicional (Volumen de transacciones por moneda)</h2>
</div>

<div id="outline-container-orgb7fd1b0" class="outline-2">
<h2 id="orgb7fd1b0"><span class="section-number-2">10.</span> Conclusiones</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-10-09 Thu 19:26</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
